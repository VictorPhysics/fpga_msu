\chapter{Работа с очередями FIFO}

\emph{Интерфес FIFO. Асинхронных режим. Режимы работы FIFO: Standard и First Word Fall Through. Интерфейс AXI Stream.}

\section{Содержание главы}

Основной литературой по FIFO является PG057. Требуется:
\begin{itemize}
\item описать всю последовательность действий по созданию и кастомизации ядра FIFO, а также включению его в код на VHDL, сделав при этом упор на интерфейс \emph{Native} и на интерфейс \emph{AXI4-Stream} (про интерфейс AXI4 Memory Mapped достаточно упомянуть);
\item написать testbench для ядра FIFO, чтобы показать его функциональность (т.е. то, как ядро работает), привести пример временных форм сигналов из симулятора;
\item описать принцип работы FIFO (описать два указателя~-- на начало и конец очереди в памяти, когда и как они увеличиваются и т.д.);
\item написать, отладить и описать VHDL-код усредняющего FIFO. Обязателен testbench.
\end{itemize}

\section{Что такое FIFO? VHDL-код FIFO на основе \\  регистров.}

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{fifo_bufer}
\caption{Концептуальная схема буфера FIFO}
\label{fifo_bufer_label}
\end{figure}

Буфер FIFO (first-in-first-out) является «эластичным» хранилищем между двумя подсистемами, как показано на концептуальной диаграмме рисунка 1.1.  Он имеет два управляющих сигнала, wr и rd, для операций записи и чтения. Когда wr устанавливается в '1', входные данные записываются в буфер. Операция чтения несколько вводит в заблуждение. Голова буфера FIFO всегда доступна и, следовательно, может быть прочитана в любое время. На самом деле сигнал rd действует как сигнал «удалить». Когда это утверждается, первый элемент (то есть голова) буфера FIFO удаляется, и становится доступным следующий элемент. Буфер FIFO является критическим компонентом во многих приложениях, и оптимизированная реализация может быть довольно сложной. В этом подразделе мы вводим простые,  кольцевые рисунки на основе циклических очередей.

\subsection{Реализация на основе циклических очередей}
Одним из способов реализации буфера FIFO является добавление схемы управления к регистровому файлу. Регистры в регистровом файле располагаются в виде круговой очереди с двумя указателями. Указатель записи указывает на начало очереди, а указатель чтения указывает на хвост очереди. Указатель продвигает одну позицию для каждой операции записи или чтения. Операция кольцевой очереди из восьми слов показана на рисунке 1.2.
	Буфер FIFO обычно содержит два сигнала состояния, полный и пустой, чтобы указать, что FIFO заполнен (т.е. не может быть записан) и пуст (т.е. не может быть прочитан) соответственно. Одно из двух условий возникает, когда указатель чтения равен указателю записи, как показано на рис. 1.2 (a), (f) и (i). Самая сложная задача разработки контроллера - получить механизм, позволяющий отличать два условия. Одна из схем заключается в использовании двух триггеров  для отслеживания пустых и полных статусов. Триггеры устанавливаются в '1' и '0' во время инициализации системы, а затем изменяются в каждом такте в соответствии со значениями wr и rd сигналов. Код показан в ниже:

\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{circular_queue}
\caption{Буфер FIFO, основанный на кольцевой очереди.}
\label{circular_queue_label}
\end{figure}

\lstinputlisting[caption=FIFO bufer, label=fifo_kur]{fifo_kur.vhd}

Код разделен на регистровый файл и контроллер FIFO. Контроллер состоит из двух указателей и двух статусных триггеров. Его логика следующего состояния исследует сигналы wr и rd и предпринимает соответствующие действия. Например, рассмотрим случай «10», из которого следует, что происходит только операция записи. Сначала проверяется статус триггера, чтобы убедиться, что буфер не заполнен. Если это условие выполняется, мы продвигаем указатель записи на одну позицию и очищаем пустой статус триггер. Хранение одного дополнительного слова в буфере может сделать его полным. Это происходит, если новый указатель записи «ловит» указатель чтения, который задается выражением w\_ pt\_r succ = r\_ ptr\_reg.

\subsection{Схема проверки}

Схема проверки проверяет работу  $2^{3} \times 3$ FIFO буфера. Мы используем три переключателя для генерации входных данных и используем две кнопки для wr и rd сигналов. 3-разрядное считывание состояния полного и пустого сигнала состояния отображаются в пяти дискретных светодиодах. Исходными входами кнопок являются btn (0) и btn (I), а ослабленные сигналы - db\_btn (0) и db\_btn (l). Код показан в листинге 1.2.

\lstinputlisting[caption=Testing circuit for a FIFO buffer, label=fifo_testing]{fifo_testing.vhd}

\section{FIFO IP}

 \noindent 
\textbf{Шаг 1: открываем проект} \\ 
\\
Считаю что данный шаг не стоит описывать подробно, так как вы неоднократно выполняли данную процедуру.\\
\\
\textbf{Шаг 2: Настройка генератора FIFO}
\begin{enumerate} 
\item Выберите IP Catalog во вкладке  Flow Navigator. 
\itemНажмите IP Catalog и он отобразится в новой вкладке.
\itemНажмите папку Memories \& Storage Element, затем FIFOs. Выберите FIFO Generator. Альтернативный способ написать в строке поиска fifo.
\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{fifo_ip_1}
\caption{ Customize IP}
\label{fifo_ip_1_label}
\end{figure}
\itemЩелкните правой кнопкой мыши и выбирете Customize IP, или дважды щелкните на FIFO Generator. Откроется окно настройки генератора FIFO.
\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{fifo_ip_2}
\caption{Xilinx IP Catalog – FIFO Core}
\label{fifo_ip_2_label}
\end{figure}
\item Выберите тип интерфейса Native.
\item Установить режим чтения Standart FIFO.
\itemЗадайте Write Width, Write Depth, Read Width.
\itemПерейдите во вкладку Status Flags, в разделе Read Port Handshaking установите галочку в Valid Flag.
\itemУбедитесь, что информация верна, как показано, и нажмите «ОК».
\end{enumerate}

\textbf{Шаг 3: Создание выходных продуктов} \\ 

После завершения настройки IP-адреса откроется диалоговое окно «Generate Output Products», как показано на следующем рисунке. Выходными продуктами для IP являются различные файлы, необходимые для поддержки использования IP в synthesis, simulation, and implementation. 
\begin{enumerate} 
\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{fifo_ip_3}
\caption{Generate Output Products}
\label{fifo_ip_3_label}
\end{figure}
\itemНажмите «Generate», чтобы создать требуемые выходные продукты (рис 1.5).\\
По умолчанию среда IDE Vivado создает файл Synthesized Checkpoint (DCP). Создание DCP показано на следующем рисунке:
\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{fifo_ip_4}
\caption{Out-of-Context Synthesis Run}
\label{fifo_ip_4_label}
\end{figure}
\item На вкладке «Ip Source»  в окне «Source» просмотрите выходные продукты, созданные для настройки генератора FIFO. Если вы не создали выходные продукты, они будут автоматически генерироваться при запуске синтеза верхнего уровня. (рис 1.6)
\item Изучите консоль Tcl в среде IDE Vivado, как показано на следующем рисунке, и просмотрите команды Tcl, используемые для добавления ядра генератора FIFO в ваш проект. (рис 1.7)
\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{fifo_ip_7}
\caption{Tcl Console Commands for Adding IP}
\label{fifo_ip_7_label}
\end{figure}
\end{enumerate} 

\begin{itemize}
\itemКоманда create\_ip добавляет IP в текущий проект.
\itemКоманда set\_property задает различные параметры конфигурации, выбранные в диалоговом окне «Настройка IP».
\itemКоманда generate\_target создает заданные выходные продукты для настроенного IP.
\itemКоманда create\_ip\_run создает синтез вне контекста для настроенного IP.
\end{itemize}

\textbf{Шаг 4: Создание IP-адреса в проекте} \\ 
Теперь вы создадите экземпляр настройки IP в проекте, скопировав и вставив шаблон верификации VHDL в соответствующий исходный файл VHDL в своем проекте и изменив сигналы.
\begin{enumerate}
\itemНа вкладке «Ip Source»  в окне «Source» разверните шаблон создания шаблона и дважды щелкните файл, чтобы открыть шаблон в текстовом редакторе Vivado.
\itemПрокрутите вниз до строки 57 файла шаблона и выберите и скопируйте текст экземпляра модуля, как показано на следующем рисунке 1.8.
\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{fifo_ip_8}
\caption{FIFO Core Generator - Instantiation Template}
\label{fifo_ip_8_label}
\end{figure}
\itemЗатем вы вставляете шаблон инстанцирования в соответствующий исходный RTL-файл. В этом случае вы вставляете модуль в верхний уровень дизайна, в исходный файл vhd.
\itemНа вкладке «Hierarchy» в представлении «Sources» дважды щелкните файл .vhd, как показано на следующем рисунке, чтобы открыть этот файл для редактирования рис (1.9).

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{fifo_ip_9}
\caption{Файл vhd}
\label{fifo_ip_9_label}
\end{figure}

\item Измените имена портов следующим образом, чтобы подключить порты модуля к дизайну (рис 1.10):

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{fifo_ip_10}
\caption{Порты}
\label{fifo_ip_10_label}
\end{figure}

\item В меню боковой панели текстового редактора нажмите кнопку Save File, чтобы сохранить изменения в файле .vhd.
\end{enumerate}

\section{Усредняющее FiFO}
\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{structure}
\caption{Структурная схема}
\label{struct}
\end{figure}

У нас есть сигнал data\_in и data\_valid. Мы подаем сначала 16 чисел в frame0 вместе с data\_valid, а затем подаем еще 16 чисел в frame1, это уже другие числа. Усредняющее FIFO должно нам выдать сумму frame0 и frame1. Усредненение - это сумма поделить на количество. Мы упростим задачу, нам не нужно будет делить. Подаем 18 битные числа на входе и получаем 18 битные числа на выходе. Они просто складываются, а элементов будет n\_average. Усредненый сигнал 
ся, когда ready равен 1. Этот сигнал символизирует, что некоторый данный приемник готов к получению данных. Сигнал data\_valid сигнализирует, что получаются верные данные, а ready сигнал готовности принимать данные.
Идея в том, что наше усредняющее FIFO ждет, когда приемник готов их принимать данные и только после этого выдает свой data\_valid вместе с данными.

У вас может возникнуть вопрос: а что будет если сумма выйдет за пределы 18 бит? Строго говоря, верный вопрос. Пусть будет переполнение, в данном случае это упрощенная задача.

Данный вопрос можно решить следующим образом, делаются не 18 битные числа, а 12 битные, а на выходе идут 18 битные. В таком случае максимальное количество усреднений, оно же максимальное количество сложений. В таком случае мы можем сделать 64=$2^6$ сложения, иначе возможно переполнение (overflow)

Конечный автомат по очереди подключает на первой иттерации, в состоянии waiting, data\_in, data\_valid\_in и полность заполняет FIFO. Затем ждет, когда будет новый data\_valid и подключает к входу rd\_anable, т.е. запрашивает данные из FIFO. При этом data\_in и data\_valid\_in он задерживает на один такт, т.е. пропускает через регистр, чтобы скомпенсировать задержку в один цикл. И на вход FIFO уже поступает сумма первого числа, которое поступило из FIFO и первого числа, которое поступило со входа.

И на последнем этапе, 3-е состояние unloading, он выжидает сигнал ready, после чего выдвет на data\_out и data\_valid\_out сигнал суммы. 

Как только data\_valid равен единичке, записываем в счетчик количество усреднений значений n\_aver, а затем уменьшаем его на единицу с каждым новым Frame`ом.

Регистры, которые обязательно потребуются: регистр, который считает числа до 16 внутри Frame, регистр который считает Frame`мы, регистр, который задерживает data\_in и data\_valid\_in, чтобы скомпенсировать задержку в один такт, которая FIFO, регистр data\_out и data\_valid\_out.

\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{simulation}
\caption{Симуляция}
\label{simulation}
\end{figure}

\begin{center}
\textbf{Ниже приведен код и тестбенч усредняющего FIFO.}
\end{center}

\lstinputlisting[caption= Код усредняющего FIFO, label=prog_nyan]{nyan.vhd}

\lstinputlisting[caption=Тестбенч усредняющего FIFO, label=prog_nyantb]{nyantb.vhd}

\section{Интерфейс FIFO}

Ядро FIFO (first-in first-out - первый вошел, первый вышел) генератора может использоваться в любом приложении, требующем упорядоченного
хранения и извлечения, что позволяет создавать высокопроизводительные и оптимизированные по площади проекты.
Ядро обеспечивает оптимизированное решение для всех конфигураций FIFO и  максимальную производительность (до 500 МГц) при использовании
минимальных ресурсов.

Это ядро поддерживает Native интерфейс, AXI Memory Mapped и AXI4-Stream interface.
Оно может быть настроено с использованием модификаторов IP Vivado в каталоге
IP как завершенное решение с уже реализованной логикой управления, включая управление указателями
чтения и записи и генерацию флагов состояния.

